---
phase: 17-virtualized-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.rs
  - benches/rendering.rs
autonomous: true

must_haves:
  truths:
    - "User experiences smooth scrolling (no lag) through large datasets at 30+ FPS"
    - "Render time remains constant regardless of dataset size (only visible rows rendered)"
    - "CPU usage drops to near-zero when application is idle (no redundant renders)"
  artifacts:
    - path: "src/main.rs"
      provides: "Frame-rate-controlled event loop with needs_redraw optimization"
      contains: "FRAME_TIME_MS"
    - path: "benches/rendering.rs"
      provides: "Viewport-windowed render benchmark proving constant render time"
      contains: "bench_viewport_render_scaling"
  key_links:
    - from: "src/main.rs"
      to: "crossterm::event::poll"
      via: "Frame-time-aware polling with 33ms target"
      pattern: "FRAME_TIME_MS"
    - from: "src/main.rs"
      to: "terminal.draw"
      via: "Conditional render gated by needs_redraw flag"
      pattern: "needs_redraw"
---

<objective>
Optimize the event loop for 30+ FPS scrolling and add benchmarks proving constant render time.

Purpose: The current 250ms event poll limits the application to 4 FPS maximum, making scrolling through large datasets feel sluggish. This plan reduces poll timeout to 33ms (~30 FPS), adds a needs_redraw flag to avoid wasting CPU when idle, and adds benchmarks that prove viewport-windowed rendering achieves constant render time regardless of dataset size.

Output: Modified event loop in src/main.rs with frame timing, updated benches/rendering.rs with viewport scaling benchmark.
</objective>

<execution_context>
@/home/jlabbe/.claude/get-shit-done/workflows/execute-plan.md
@/home/jlabbe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-virtualized-rendering/17-RESEARCH.md
@src/main.rs
@src/render.rs
@benches/rendering.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement frame-rate-controlled event loop with needs_redraw optimization</name>
  <files>src/main.rs</files>
  <action>
Modify the main event loop in src/main.rs to achieve 30 FPS frame timing with idle optimization:

1. Add constants near the top of the main event loop section:
   ```rust
   const TARGET_FPS: u64 = 30;
   const FRAME_TIME_MS: u64 = 1000 / TARGET_FPS; // 33ms
   ```

2. Add state variables before the main loop:
   ```rust
   let mut last_render = Instant::now();
   let mut needs_redraw = true; // Always render first frame
   ```

3. Replace the current `event::poll(Duration::from_millis(250))` block (line ~720) with frame-time-aware polling:
   ```rust
   let now = Instant::now();
   let elapsed = now.duration_since(last_render).as_millis() as u64;
   let poll_duration = FRAME_TIME_MS.saturating_sub(elapsed).max(1);

   if event::poll(Duration::from_millis(poll_duration))? {
       if let Event::Key(key) = event::read()? {
           needs_redraw = true; // Any key event triggers redraw
           // ... existing key handling unchanged ...
       }
   }
   ```

4. Set `needs_redraw = true` in these additional places:
   - After streaming loader receives new rows (the `if !new_rows.is_empty()` block near line 277)
   - After streaming completion detection (the `had_streaming_loader && streaming_loader.is_none()` block)
   - The first iteration (already initialized to true)

5. Wrap the entire render section (from "Build tab bar string" through the `terminal.draw()` call and TableState translation back) in a conditional:
   ```rust
   if needs_redraw || now.duration_since(last_render).as_millis() as u64 >= FRAME_TIME_MS {
       // ... existing render code (tab bar, pane data, terminal.draw, translation back) ...
       last_render = Instant::now();
       needs_redraw = false;
   }
   ```

6. Also set `needs_redraw = true` when the streaming loader is active (since row count changes need to be reflected in loading indicator). The existing `if streaming_loader.is_some()` block that sets status_message already handles this -- just add `needs_redraw = true;` there.

IMPORTANT: Do NOT change the structure of the event handlers. Only modify:
- The poll duration calculation
- The conditional gating of the render block
- Adding needs_redraw flag management

Keep the memory refresh at every 30 frames (unchanged - already calibrated for ~1 second intervals at 30 FPS).

Do NOT wrap the streaming loader poll in the needs_redraw conditional -- streaming data must always be consumed regardless of render state.

Why 33ms not 16ms: 30 FPS is the success criterion target. 60 FPS would double CPU usage for minimal perceptible benefit in terminal rendering. Terminal emulators typically refresh at lower rates than GUI applications.
  </action>
  <verify>
1. `cargo build` compiles without errors
2. `cargo test` -- all existing tests pass (no regressions)
3. `cargo clippy` -- no new warnings
4. Grep for FRAME_TIME_MS in src/main.rs confirms frame timing constant exists
5. Grep for needs_redraw in src/main.rs confirms flag is used in render gating
  </verify>
  <done>
Event loop uses 33ms poll timeout instead of 250ms. Render is gated by needs_redraw flag. Application compiles and all tests pass. Scrolling responsiveness improved from ~4 FPS to ~30 FPS target.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add viewport render scaling benchmark proving constant render time</name>
  <files>benches/rendering.rs</files>
  <action>
Add a new benchmark to benches/rendering.rs that proves viewport-windowed rendering achieves constant render time regardless of dataset size:

1. Add a new benchmark function `bench_viewport_render_scaling`:
   ```rust
   /// Benchmark viewport-windowed render data at different dataset sizes.
   /// Proves render time is O(viewport_size), not O(dataset_size).
   /// All tests use viewport_height=50 (typical terminal height).
   fn bench_viewport_render_scaling(c: &mut Criterion) {
       let mut group = c.benchmark_group("viewport_render_scaling");
       let viewport_height: usize = 50; // Typical terminal height

       // Test with drastically different dataset sizes
       // If viewport windowing works, all should take similar time
       for num_rows in [1_000, 10_000, 100_000, 500_000] {
           let data = create_test_table(num_rows, 10);
           let mut tab = Tab::new("benchmark".to_string(), data, ViewMode::PipeData);
           // Initialize cached widths (as the app would in practice)
           tab.update_cached_widths();

           // Position cursor at middle of dataset
           tab.table_state.select(Some(num_rows / 2));

           group.bench_with_input(
               BenchmarkId::new("rows", num_rows),
               &tab,
               |b, tab| {
                   b.iter(|| {
                       let render_data = build_pane_render_data(black_box(tab), viewport_height);
                       black_box(render_data)
                   });
               },
           );
       }

       group.finish();
   }
   ```

2. Add a second benchmark `bench_viewport_render_at_boundaries` that tests render performance at different scroll positions (top, middle, bottom):
   ```rust
   /// Benchmark render data at different scroll positions (top, middle, bottom).
   /// Verifies no performance degradation at dataset boundaries.
   fn bench_viewport_render_at_boundaries(c: &mut Criterion) {
       let mut group = c.benchmark_group("viewport_render_boundaries");
       let viewport_height: usize = 50;
       let num_rows: usize = 100_000;
       let data = create_test_table(num_rows, 10);

       for (label, position) in [
           ("top", 0usize),
           ("middle", num_rows / 2),
           ("bottom", num_rows - 1),
       ] {
           let mut tab = Tab::new("benchmark".to_string(), data.clone(), ViewMode::PipeData);
           tab.update_cached_widths();
           tab.table_state.select(Some(position));

           group.bench_with_input(
               BenchmarkId::new("position", label),
               &tab,
               |b, tab| {
                   b.iter(|| {
                       let render_data = build_pane_render_data(black_box(tab), viewport_height);
                       black_box(render_data)
                   });
               },
           );
       }

       group.finish();
   }
   ```

3. Register both new benchmarks in the criterion_group! macro:
   ```rust
   criterion_group!(
       benches,
       bench_column_width_calculation,
       bench_build_render_data,
       bench_viewport_render_scaling,
       bench_viewport_render_at_boundaries
   );
   ```

4. You need to import `Tab` and `ViewMode` from workspace if not already imported (check existing imports).

The key verification: the `viewport_render_scaling` benchmark should show roughly constant time across 1K, 10K, 100K, and 500K rows. If 500K takes significantly longer than 1K, the viewport windowing has a regression.
  </action>
  <verify>
1. `cargo bench --bench rendering -- --test` -- benchmark compiles and runs (use --test for quick validation, not full benchmark)
2. `cargo bench --bench rendering -- viewport_render_scaling` -- run the scaling benchmark and verify times are roughly constant across dataset sizes (within 2x, not 100x)
3. `cargo bench --bench rendering -- viewport_render_boundaries` -- run boundary benchmark and verify top/middle/bottom have similar performance
  </verify>
  <done>
Viewport render scaling benchmark exists in benches/rendering.rs. Running it proves render time is constant regardless of dataset size (1K vs 500K rows take similar time with viewport_height=50). Boundary benchmark proves no performance regression at top/middle/bottom scroll positions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- clean compilation
2. `cargo test` -- all existing tests pass
3. `cargo bench --bench rendering -- viewport_render_scaling` -- constant render time across dataset sizes
4. Grep for `FRAME_TIME_MS` and `needs_redraw` in src/main.rs confirms frame timing optimization
</verification>

<success_criteria>
- Event loop polls at 33ms (30 FPS target) instead of 250ms (4 FPS)
- needs_redraw flag prevents unnecessary renders when idle
- Benchmark proves viewport-windowed render time is constant (O(viewport_size), not O(dataset_size))
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/17-virtualized-rendering/17-01-SUMMARY.md`
</output>
