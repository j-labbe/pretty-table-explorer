---
phase: 17-virtualized-rendering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/scroll_tests.rs
  - src/render.rs
autonomous: true

must_haves:
  truths:
    - "Scroll position stays accurate at row 0 (top of dataset)"
    - "Scroll position stays accurate at the last row (bottom of dataset)"
    - "Scroll position stays accurate at midpoint of large datasets"
    - "Viewport windowing handles filtered data correctly at boundaries"
    - "Empty datasets and single-row datasets render without panics"
  artifacts:
    - path: "tests/scroll_tests.rs"
      provides: "Integration tests for viewport boundary conditions"
      min_lines: 80
  key_links:
    - from: "tests/scroll_tests.rs"
      to: "src/render.rs build_pane_render_data"
      via: "Direct function call testing viewport windowing output"
      pattern: "build_pane_render_data"
    - from: "src/render.rs"
      to: "viewport_row_offset"
      via: "Correct offset calculation at all boundary conditions"
      pattern: "viewport_row_offset"
---

<objective>
Add comprehensive scroll boundary tests proving viewport windowing is accurate at all dataset positions.

Purpose: Off-by-one errors in virtualized scrolling are the most common failure mode (noted in research and STATE.md concerns). This plan creates integration tests that verify scroll position accuracy at top, middle, and bottom of datasets, with both unfiltered and filtered data, plus edge cases (empty data, single row). These tests serve as regression protection for the viewport windowing logic.

Output: New test file tests/scroll_tests.rs with boundary condition tests.
</objective>

<execution_context>
@/home/jlabbe/.claude/get-shit-done/workflows/execute-plan.md
@/home/jlabbe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-virtualized-rendering/17-RESEARCH.md
@src/render.rs
@src/state.rs
@src/workspace.rs
@tests/search_tests.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scroll boundary integration tests</name>
  <files>tests/scroll_tests.rs</files>
  <action>
Create tests/scroll_tests.rs with comprehensive boundary condition tests for viewport windowing.

Use the same test helper pattern as existing integration tests (see tests/search_tests.rs for TableData creation with lasso::Rodeo).

Create helper function:
```rust
use lasso::Rodeo;
use pretty_table_explorer::parser::TableData;
use pretty_table_explorer::render::build_pane_render_data;
use pretty_table_explorer::workspace::{Tab, ViewMode};

fn create_test_data(num_rows: usize, num_cols: usize) -> TableData {
    let headers: Vec<String> = (1..=num_cols).map(|i| format!("col_{}", i)).collect();
    let mut interner = Rodeo::default();
    let rows = (0..num_rows)
        .map(|row| {
            (0..num_cols)
                .map(|col| interner.get_or_intern(format!("r{}_c{}", row, col)))
                .collect()
        })
        .collect();
    TableData { headers, rows, interner }
}
```

Write these test cases:

1. **test_viewport_at_top** - Selected row 0 with viewport_height=25:
   - viewport_row_offset should be 0
   - display_rows should start with the first row's data
   - displayed_row_count should equal total row count (no filter)

2. **test_viewport_at_bottom** - Selected row = total_rows - 1 with viewport_height=25:
   - display_rows should include the last row
   - The last row's content should match expected value (e.g., "r{total-1}_c0")
   - No panic or index-out-of-bounds

3. **test_viewport_at_middle** - Selected row = total_rows / 2 with viewport_height=25:
   - viewport_row_offset should be approximately (total/2 - 50) (buffer = viewport_height * 2)
   - display_rows should contain the selected row's data
   - The selected row should be present in the viewport window

4. **test_viewport_row_count_unfiltered** - Various dataset sizes (10, 100, 10000):
   - displayed_row_count equals total row count
   - display_rows.len() is min(total_rows, buffer * 2) -- capped by viewport window

5. **test_viewport_empty_dataset** - Zero rows:
   - display_rows is empty
   - displayed_row_count is 0
   - viewport_row_offset is 0
   - No panic

6. **test_viewport_single_row** - One row, selected=0, viewport_height=25:
   - display_rows has exactly 1 row
   - viewport_row_offset is 0
   - Content matches expected value

7. **test_viewport_small_dataset** - 5 rows, viewport_height=25 (dataset smaller than viewport):
   - All 5 rows are in display_rows (buffer encompasses entire dataset)
   - viewport_row_offset is 0
   - displayed_row_count is 5

8. **test_viewport_with_filter_at_boundaries** - 1000 rows, filter text matching ~10% (use "r0" which matches r0, r10-r19, r100-r199, etc.):
   - Set tab.filter_text = "r0".to_string()
   - Select row 0 (first filtered match) -- verify display_rows contains filtered data
   - Select row = displayed_row_count - 1 (last filtered match) -- verify no panic

9. **test_viewport_offset_consistency** - 10000 rows, viewport_height=25:
   - Walk through positions 0, 100, 500, 5000, 9999
   - At each position: verify viewport_row_offset + display_rows.len() does not exceed total_rows (or displayed_row_count for filtered)
   - Verify viewport_row_offset <= selected row index

Each test uses build_pane_render_data(tab, viewport_height) and asserts on PaneRenderData fields.

For the filter test: set tab.filter_text before calling build_pane_render_data. The function handles filtering internally.

Use `assert!()` with descriptive messages for boundary checks. Use `assert_eq!()` for exact values.
  </action>
  <verify>
1. `cargo test --test scroll_tests` -- all scroll boundary tests pass
2. `cargo test` -- all existing tests still pass (no regressions)
3. Verify test file exists and has tests for top, middle, bottom, empty, single-row, filter cases
  </verify>
  <done>
9+ scroll boundary tests exist in tests/scroll_tests.rs. All pass. Tests cover: top boundary (row 0), bottom boundary (last row), middle position, empty dataset, single row, small dataset, filtered boundaries, and offset consistency across positions. No off-by-one errors detected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix any boundary issues found by tests and verify render.rs correctness</name>
  <files>src/render.rs</files>
  <action>
After running the boundary tests from Task 1, examine any failures and fix boundary issues in src/render.rs build_pane_render_data().

Known areas to verify (from research pitfalls):

1. **Boundary safety of viewport window calculation** (lines 90-107 of render.rs):
   - `selected.saturating_sub(buffer)` -- safe for row 0 (saturating prevents underflow)
   - `selected.saturating_add(buffer).min(total)` -- safe for last row (min prevents overflow)
   - Verify: when selected=0, start=0 (correct). When selected=total-1, end=total (correct).

2. **Filter path boundary safety** (lines 108-134):
   - `filtered_indices[start..end]` -- verify start and end are within filtered_indices bounds
   - When selected > filtered_indices.len(): could cause out-of-bounds
   - If filter returns 0 matches: display_rows should be empty, not panic

3. **Selected row clamping for filtered data:**
   - If user is at row 500 and filter reduces to 100 matches, selected=500 exceeds filtered_indices.len()
   - The viewport window calculation uses `selected.saturating_sub(buffer)` and `selected.saturating_add(buffer).min(total)` where total=filtered_indices.len()
   - With selected=500 and total=100: start=500-50=450, end=min(550,100)=100
   - This means start(450) > end(100) which creates an empty slice -- CORRECT behavior but verify this doesn't cause issues

4. **Potential fix needed:** If selected > total in the filtered path, the start > end scenario creates an empty display_rows. This is technically correct (the calling code in handlers should clamp selected), but add a defensive clamp:
   ```rust
   let selected = tab.table_state.selected().unwrap_or(0);
   ```
   Consider adding after the filter indices collection:
   ```rust
   let selected = selected.min(total.saturating_sub(1));
   ```
   Only add this if tests reveal the issue. Do NOT add unnecessary changes if all tests pass.

If ALL tests from Task 1 pass without any changes to render.rs, document that in the summary: "Viewport windowing logic verified correct at all boundaries. No fixes needed."

If fixes ARE needed, make minimal targeted changes with comments explaining the boundary condition being addressed.
  </action>
  <verify>
1. `cargo test --test scroll_tests` -- all boundary tests pass (including any fixed cases)
2. `cargo test` -- all existing tests pass
3. `cargo clippy` -- no warnings
4. `cargo build --release` -- release build succeeds
  </verify>
  <done>
Viewport windowing logic in render.rs is verified correct at all boundary conditions (or fixed if issues found). All scroll boundary tests pass. All existing tests pass. No off-by-one errors in viewport calculation at top, middle, or bottom of dataset.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- all tests pass (existing + new scroll boundary tests)
2. `cargo test --test scroll_tests` -- specifically scroll boundary tests pass
3. `cargo clippy` -- clean
4. `cargo build --release` -- clean build
</verification>

<success_criteria>
- Scroll boundary tests exist covering top, middle, bottom, empty, single-row, filtered boundaries
- All tests pass -- proving viewport windowing handles all positions correctly
- No off-by-one errors at dataset boundaries
- Any discovered boundary issues fixed in render.rs
</success_criteria>

<output>
After completion, create `.planning/phases/17-virtualized-rendering/17-02-SUMMARY.md`
</output>
