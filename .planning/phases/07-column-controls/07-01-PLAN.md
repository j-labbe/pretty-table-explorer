---
phase: 07-column-controls
plan: 01
type: execute
depends_on: []
files_modified: [src/column.rs, src/main.rs]
---

<objective>
Add column state management with width overrides to enable manual column resizing.

Purpose: Foundation for column controls - track per-column state (visibility, width override, display order) and apply width overrides during rendering.
Output: New column.rs module with ColumnConfig, integration with main.rs rendering, and +/- keybindings for width adjustment.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/main.rs
@src/parser.rs

**Key context from codebase:**
- `calculate_widths()` in main.rs computes column widths from content (lines 84-107)
- `widths` is `Vec<Constraint>` used by ratatui Table widget
- `table_data.headers` provides column count
- h/l keys navigate columns, TableState tracks selected column
- Widths recalculated when data changes (line 225, 443, 469, 583)

**Established patterns:**
- Module per concern (db.rs, parser.rs, update.rs)
- State structs with derive Debug, Clone
- Keybindings in match block inside main event loop
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create column state module</name>
  <files>src/column.rs</files>
  <action>Create new module with:

  ```rust
  /// Per-column display configuration
  #[derive(Debug, Clone)]
  pub struct ColumnState {
      /// Width override (None = auto-size)
      pub width_override: Option<u16>,
      /// Whether column is visible
      pub visible: bool,
  }

  /// Manages column display configuration for a table
  #[derive(Debug, Clone)]
  pub struct ColumnConfig {
      columns: Vec<ColumnState>,
  }

  impl ColumnConfig {
      /// Create config for n columns (all visible, auto-width)
      pub fn new(num_columns: usize) -> Self

      /// Reset to auto-size for all columns
      pub fn reset(&mut self)

      /// Adjust width override for column (min 3, max 100)
      pub fn adjust_width(&mut self, col: usize, delta: i16)

      /// Get width override for column (None = auto)
      pub fn get_width(&self, col: usize) -> Option<u16>

      /// Check if column is visible
      pub fn is_visible(&self, col: usize) -> bool
  }
  ```

  Width bounds: min 3 (readable), max 100 (practical limit). When adjusting, if override is None, start from a default of 10.
  </action>
  <verify>cargo check passes, cargo test passes</verify>
  <done>column.rs exists with ColumnConfig struct and width methods, compiles cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Integrate column config with rendering</name>
  <files>src/main.rs</files>
  <action>
  1. Add `mod column;` at top with other modules
  2. Add `use column::ColumnConfig;` import
  3. Create `column_config` state variable after `widths` initialization:
     ```rust
     let mut column_config = ColumnConfig::new(table_data.headers.len());
     ```
  4. Modify `calculate_widths` to accept optional `&ColumnConfig` parameter:
     - If column has width_override, use that instead of auto-calculated width
     - Signature: `fn calculate_widths(data: &TableData, config: Option<&ColumnConfig>) -> Vec<Constraint>`
  5. Update all calls to `calculate_widths` to pass `Some(&column_config)`:
     - Line 225 (initial)
     - Line 443 (table select)
     - Line 469 (Esc back)
     - Line 583 (query result)
  6. Reset column_config when data changes (after each calculate_widths call for new data):
     ```rust
     column_config = ColumnConfig::new(table_data.headers.len());
     ```

  Do NOT add keybindings yet - that's Task 3.
  </action>
  <verify>cargo build --release succeeds, existing functionality unchanged (navigate, filter, query)</verify>
  <done>Column config integrated, calculate_widths respects overrides, app runs normally</done>
</task>

<task type="auto">
  <name>Task 3: Add width adjustment keybindings</name>
  <files>src/main.rs</files>
  <action>
  Add keybindings in the AppMode::Normal match block:

  ```rust
  // Column width adjustment (+ and - keys)
  KeyCode::Char('+') | KeyCode::Char('=') => {
      if let Some(col) = table_state.selected_column() {
          column_config.adjust_width(col, 2);
          widths = calculate_widths(&table_data, Some(&column_config));
      }
  }
  KeyCode::Char('-') | KeyCode::Char('_') => {
      if let Some(col) = table_state.selected_column() {
          column_config.adjust_width(col, -2);
          widths = calculate_widths(&table_data, Some(&column_config));
      }
  }
  // Reset column widths to auto
  KeyCode::Char('0') => {
      column_config.reset();
      widths = calculate_widths(&table_data, Some(&column_config));
  }
  ```

  Place after PageDown handler (around line 553) and before the catch-all `_ => {}`.

  Also update the title controls string in ViewMode match to show new keybindings. For TableData mode, update from:
  "Esc: back, /: filter, :: query, q: quit"
  to:
  "Esc: back, /: filter, :: query, +/-: resize col, q: quit"

  Similar update for PipeData mode controls.
  </action>
  <verify>cargo run with test data, use h/l to select column, +/- to resize, 0 to reset</verify>
  <done>+/- resize selected column, 0 resets all widths, controls shown in title</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds without warnings
- [ ] `cargo test` passes all tests
- [ ] Piped data mode works: `echo " a | b\n---+---\n 1 | 2" | cargo run`
- [ ] Column resize works: h/l to select, +/- to resize
- [ ] Reset works: 0 returns to auto-widths
- [ ] Resized widths persist during navigation until reset or data change
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings
- Column width overrides work with +/- keys
- 0 key resets to auto-width
- Title shows new keybindings
</success_criteria>

<output>
After completion, create `.planning/phases/07-column-controls/07-01-SUMMARY.md`
</output>
