---
phase: 07-column-controls
plan: 03
type: execute
depends_on: ["07-02"]
files_modified: [src/column.rs, src/main.rs]
---

<objective>
Add column reordering functionality to move columns left/right.

Purpose: Allow users to rearrange columns to put important data side-by-side without modifying underlying data.
Output: < and > keys move selected column left/right, reorder persists until reset.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-column-controls/07-02-SUMMARY.md
@src/column.rs
@src/main.rs

**From Plan 01-02:**
- ColumnConfig tracks per-column state
- visible_indices() returns ordered visible columns
- Rendering uses visible_indices for column order
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add display order tracking to ColumnConfig</name>
  <files>src/column.rs</files>
  <action>
  Modify ColumnConfig to track display order:

  1. Add display_order field to ColumnConfig:
     ```rust
     pub struct ColumnConfig {
         columns: Vec<ColumnState>,
         /// Display order - indices into columns vec
         display_order: Vec<usize>,
     }
     ```

  2. Update new() to initialize display_order:
     ```rust
     pub fn new(num_columns: usize) -> Self {
         Self {
             columns: (0..num_columns)
                 .map(|_| ColumnState {
                     width_override: None,
                     visible: true,
                 })
                 .collect(),
             display_order: (0..num_columns).collect(),
         }
     }
     ```

  3. Update reset() to also reset display_order:
     ```rust
     pub fn reset(&mut self) {
         for col in &mut self.columns {
             col.width_override = None;
             col.visible = true;
         }
         self.display_order = (0..self.columns.len()).collect();
     }
     ```

  4. Update visible_indices() to respect display_order:
     ```rust
     pub fn visible_indices(&self) -> Vec<usize> {
         self.display_order
             .iter()
             .filter(|&&i| self.columns[i].visible)
             .copied()
             .collect()
     }
     ```

  5. Add reorder methods:
     ```rust
     /// Move column at display position left (swap with previous)
     /// Returns new display position of the moved column
     pub fn move_left(&mut self, display_pos: usize) -> Option<usize> {
         if display_pos > 0 && display_pos < self.display_order.len() {
             self.display_order.swap(display_pos, display_pos - 1);
             Some(display_pos - 1)
         } else {
             None
         }
     }

     /// Move column at display position right (swap with next)
     /// Returns new display position of the moved column
     pub fn move_right(&mut self, display_pos: usize) -> Option<usize> {
         if display_pos + 1 < self.display_order.len() {
             self.display_order.swap(display_pos, display_pos + 1);
             Some(display_pos + 1)
         } else {
             None
         }
     }

     /// Get display position for a given column index
     pub fn display_position(&self, col_idx: usize) -> Option<usize> {
         self.display_order.iter().position(|&i| i == col_idx)
     }
     ```
  </action>
  <verify>cargo check passes</verify>
  <done>ColumnConfig tracks display_order, has move_left/move_right methods</done>
</task>

<task type="auto">
  <name>Task 2: Add reorder keybindings</name>
  <files>src/main.rs</files>
  <action>
  Add keybindings in AppMode::Normal match block:

  ```rust
  // Move column left (<)
  KeyCode::Char('<') | KeyCode::Char(',') => {
      if let Some(col) = table_state.selected_column() {
          // col is the display position among visible columns
          let visible = column_config.visible_indices();
          if col < visible.len() {
              // Get the actual column index at this display position
              let actual_idx = visible[col];
              // Find its position in display_order
              if let Some(display_pos) = column_config.display_position(actual_idx) {
                  // Find previous visible column's display_pos
                  if col > 0 {
                      let prev_actual = visible[col - 1];
                      if let Some(prev_display) = column_config.display_position(prev_actual) {
                          // Swap in display_order
                          column_config.move_left(display_pos.max(prev_display));
                          // Recalculate widths (order changed)
                          widths = calculate_widths(&table_data, Some(&column_config));
                          // Move selection to follow the column
                          table_state.select_previous_column();
                      }
                  }
              }
          }
      }
  }

  // Move column right (>)
  KeyCode::Char('>') | KeyCode::Char('.') => {
      if let Some(col) = table_state.selected_column() {
          let visible = column_config.visible_indices();
          if col < visible.len() {
              let actual_idx = visible[col];
              if let Some(display_pos) = column_config.display_position(actual_idx) {
                  if col + 1 < visible.len() {
                      let next_actual = visible[col + 1];
                      if let Some(next_display) = column_config.display_position(next_actual) {
                          column_config.move_right(display_pos.min(next_display));
                          widths = calculate_widths(&table_data, Some(&column_config));
                          table_state.select_next_column();
                      }
                  }
              }
          }
      }
  }
  ```

  Note: The logic is complex because display_order tracks ALL columns, but we want to swap visible columns. Simpler approach - just swap the two indices in display_order directly:

  Actually, simplify to:
  ```rust
  // Move column left (<)
  KeyCode::Char('<') | KeyCode::Char(',') => {
      if let Some(col) = table_state.selected_column() {
          let visible = column_config.visible_indices();
          if col > 0 && col < visible.len() {
              // Swap this column with previous in display order
              let this_idx = visible[col];
              let prev_idx = visible[col - 1];
              let this_pos = column_config.display_position(this_idx).unwrap();
              let prev_pos = column_config.display_position(prev_idx).unwrap();
              // Direct swap in display_order vec
              column_config.swap_display(this_pos, prev_pos);
              widths = calculate_widths(&table_data, Some(&column_config));
              table_state.select_previous_column();
          }
      }
  }
  ```

  Add swap_display method to column.rs:
  ```rust
  pub fn swap_display(&mut self, pos1: usize, pos2: usize) {
      if pos1 < self.display_order.len() && pos2 < self.display_order.len() {
          self.display_order.swap(pos1, pos2);
      }
  }
  ```

  Update title controls to mention reorder (keep concise):
  - TableData: "Esc: back, /: filter, </>: reorder col, q: quit"
  - PipeData: "/: filter, </>: reorder col, q: quit"

  Actually keep the old format and just add </> since space is limited.
  </action>
  <verify>cargo run, use < and > to reorder columns, verify selection follows moved column</verify>
  <done>< and > reorder columns, selection tracks moved column, 0 resets order</done>
</task>

<task type="auto">
  <name>Task 3: Update calculate_widths for display order</name>
  <files>src/main.rs</files>
  <action>
  Ensure calculate_widths returns widths in display order (not original order).

  The calculate_widths function should return widths for ALL columns in original order. The visible_indices already handles display order for rendering.

  But widths need to match the order used in Table::new(). Currently we do:
  ```rust
  let visible_widths: Vec<Constraint> = visible_cols.iter().map(|&i| widths[i].clone()).collect();
  ```

  This is correct - we pick widths by original index, in visible display order.

  Add a test to verify reorder + resize + hide all work together:
  1. Make column_config.reset() also reset display_order (already done in Task 1)
  2. Verify the whole flow works with cargo run

  If all working, update controls in title to be:
  - TableData: "+/-/0: width, H/S: hide/show, </>: move, q: quit"
  - PipeData: "+/-/0: width, H/S: hide/show, </>: move, q: quit"
  - TableList: keep simpler "Enter: select, /: filter, q: quit"
  </action>
  <verify>cargo run, test all controls: resize, hide, reorder, reset</verify>
  <done>All column controls work together, reset clears all customizations</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds without warnings
- [ ] `cargo test` passes all tests
- [ ] < key moves selected column left
- [ ] > key moves selected column right
- [ ] Selection follows the moved column
- [ ] Cannot move leftmost column left or rightmost right
- [ ] Reorder persists during navigation
- [ ] 0 key resets column order (and widths and visibility)
- [ ] All three features work together: resize + hide + reorder
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings
- Column reordering works with </> keys
- All column controls (resize/hide/reorder/reset) work together
- Phase 7 complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-column-controls/07-03-SUMMARY.md`
</output>
