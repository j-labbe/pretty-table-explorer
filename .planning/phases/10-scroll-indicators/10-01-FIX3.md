---
phase: 10-scroll-indicators
plan: 10-01-FIX3
type: fix
---

<objective>
Fix 1 UAT issue from plan 10-01.

Source: 10-01-ISSUES.md
Priority: 0 critical, 1 major, 0 minor
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/10-scroll-indicators/10-01-ISSUES.md

**Original plan for reference:**
@.planning/phases/10-scroll-indicators/10-01-PLAN.md

**Key source file:**
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix column navigation to scroll correctly past wide columns</name>
  <files>src/main.rs</files>
  <action>
The issue is in the scroll adjustment logic around lines 750-753. When navigating right to a column that's beyond the viewport, the code increments `scroll_col_offset` by 1 per frame, which causes "inching" for wide columns.

**Current problematic code (lines 750-753):**
```rust
while tab.selected_visible_col > last_visible_col_idx.get() && tab.scroll_col_offset < visible_cols.len() - 1 {
    tab.scroll_col_offset += 1;
    last_visible_col_idx.set(tab.selected_visible_col);
}
```

The `last_visible_col_idx.set(tab.selected_visible_col)` immediately breaks out of the loop after one increment. The fix should calculate how much to scroll to bring the selected column into view.

**Fix approach:**

1. In the key handler for Right/l (lines 1146-1152), after incrementing `selected_visible_col`, immediately calculate and set the proper `scroll_col_offset` instead of relying on the render loop.

2. The goal: When user presses right arrow on a wide column, the viewport should scroll enough to show the next column, not just "inch" by one column.

3. Calculate how many columns to scroll:
   - The selected column must be within the viewport
   - Calculate based on column widths which scroll_col_offset brings the selected column into the visible range

4. Simplest fix: After incrementing `selected_visible_col`, check if it will be beyond the current viewport and if so, set `scroll_col_offset` to position it as the last visible column (scroll enough to bring it into view).

**Implementation:**

In KeyCode::Char('l') | KeyCode::Right handler, after the increment:

```rust
KeyCode::Char('l') | KeyCode::Right => {
    let visible_cols = tab.column_config.visible_indices();
    if tab.selected_visible_col + 1 < visible_cols.len() {
        tab.selected_visible_col += 1;
        // Calculate scroll needed to show the selected column
        // Simple approach: if selected is beyond what we estimate fits,
        // scroll it to be the leftmost visible column (ensures it's fully visible)
        // This ensures we scroll enough in one step, not incrementally

        // We need to estimate if the new column will be visible.
        // Since we don't have width info here easily, use the simpler approach:
        // Set scroll_col_offset to show selected column as the first visible
        // ONLY if it would be beyond current scroll + reasonable window.

        // Better approach: Set scroll_col_offset such that selected_visible_col
        // is the FIRST visible column when navigating right past viewport boundary.
        // The render loop will then naturally show it and any following columns that fit.

        // Check: if selected_visible_col > scroll_col_offset + 1, there might be room.
        // The render loop's last_visible_col_idx will handle showing enough columns.

        // The cleanest fix: when the selected column was previously the last visible
        // (or beyond), scroll it to be the first visible. This guarantees one-step scroll.
    }
}
```

**Better analysis:**
The root cause is the render-loop scroll logic only scrolls by 1 and breaks immediately.

Remove the `last_visible_col_idx.set(tab.selected_visible_col);` line from inside the while loop - it should NOT break the loop early. The loop condition should naturally terminate when `scroll_col_offset` has been incremented enough to make `selected_visible_col` visible (which is tracked by the actual render calculation, not set prematurely).

Actually, the real issue is that the while loop needs to run multiple times to scroll far enough for a wide column, but it's rendered only once per frame. The `last_visible_col_idx` is recalculated during render.

**Correct fix:**
Change the input handler (Right key) to set `scroll_col_offset = selected_visible_col` when the selected column is definitely off-screen to the right. This brings the newly selected column to be the first visible, guaranteeing it's shown.

In the Right key handler:
```rust
KeyCode::Char('l') | KeyCode::Right => {
    let visible_cols = tab.column_config.visible_indices();
    if tab.selected_visible_col + 1 < visible_cols.len() {
        tab.selected_visible_col += 1;
        // Ensure the selected column is visible by making it the first visible
        // This provides immediate scroll rather than incremental "inching"
        if tab.selected_visible_col > tab.scroll_col_offset {
            // The column will be rendered; the render loop handles if it fits.
            // But if we suspect it won't fit as-is, scroll to it directly.
            // Simple heuristic: if we're navigating right, ensure we scroll at least
            // enough to show the selected column as the first column if needed.
            // This is handled by render loop, but to avoid multi-frame delay:
            // Just keep scroll_col_offset <= selected_visible_col (already true)
        }
    }
}
```

**Final fix approach:**
The issue is in the render loop's scroll adjustment (lines 750-753). The line `last_visible_col_idx.set(tab.selected_visible_col)` is wrong - it breaks the loop immediately and doesn't allow multiple increments in one frame.

Delete that line. Let the loop run until `scroll_col_offset` is high enough. The render will then correctly calculate `last_visible_col_idx` based on actual column widths.

But wait - the loop condition uses `last_visible_col_idx.get()` which is set from previous render. After incrementing scroll_col_offset, what's visible changes. The loop as-is can't know when to stop without re-rendering.

**Correct solution:**
Make the scroll happen eagerly in input handler, not render loop.

When pressing right:
1. Increment selected_visible_col
2. If selected_visible_col > estimated last visible, set scroll_col_offset = selected_visible_col

This brings the selected column to the LEFT edge of the viewport, guaranteeing it's visible in one step.

Modify the Right key handler:
```rust
KeyCode::Char('l') | KeyCode::Right => {
    let visible_cols = tab.column_config.visible_indices();
    if tab.selected_visible_col + 1 < visible_cols.len() {
        let was_last_visible = tab.selected_visible_col >= last_visible_col_idx.get();
        tab.selected_visible_col += 1;
        // If we were on or past the last visible column, scroll to show new column
        if was_last_visible {
            tab.scroll_col_offset = tab.selected_visible_col;
        }
    }
}
```

This requires `last_visible_col_idx` to be accessible in the input handler. It's currently defined inside the loop. Either make it a Tab field, or use a simpler heuristic.

**Simplest working fix:**
In the render-loop scroll adjustment, instead of incrementing by 1, set `scroll_col_offset = selected_visible_col` directly when selected is beyond last visible. This ensures the selected column becomes the first visible, not just slightly more visible.

Replace:
```rust
while tab.selected_visible_col > last_visible_col_idx.get() && tab.scroll_col_offset < visible_cols.len() - 1 {
    tab.scroll_col_offset += 1;
    last_visible_col_idx.set(tab.selected_visible_col);
}
```

With:
```rust
if tab.selected_visible_col > last_visible_col_idx.get() {
    // Scroll so selected column is the first visible (leftmost)
    // This ensures we scroll enough in one step, even for wide columns
    tab.scroll_col_offset = tab.selected_visible_col.min(visible_cols.len() - 1);
}
```

This makes the selected column the leftmost visible column when scrolling right, ensuring it's always fully visible in one frame.
  </action>
  <verify>
    `cargo build --release` passes. Navigate to a wide column and press right arrow - the next column should be selected and visible immediately without "inching".
  </verify>
  <done>Right arrow navigation past wide columns scrolls immediately to show the next column, not incrementally.</done>
</task>

<task type="auto">
  <name>Task 2: Verify left navigation still works correctly</name>
  <files>src/main.rs</files>
  <action>
Ensure left navigation (h/Left key) still works correctly:
- Check that the existing left scroll logic (`if tab.selected_visible_col < tab.scroll_col_offset { tab.scroll_col_offset = tab.selected_visible_col; }`) still provides immediate scroll behavior.
- This already sets scroll_col_offset directly to selected_visible_col, which should work correctly.
- Test: Navigate right past a wide column, then navigate left - should scroll smoothly without issues.
  </action>
  <verify>`cargo test` passes. Left navigation continues to work smoothly.</verify>
  <done>Left navigation confirmed working. Both left and right navigation provide immediate scroll behavior.</done>
</task>

<task type="auto">
  <name>Task 3: Test edge cases and verify all scroll indicators still work</name>
  <files>src/main.rs</files>
  <action>
Verify:
1. Navigate to first column - no left indicator, selection correct
2. Navigate past last column - right indicator disappears when all columns visible
3. Middle of wide table - both indicators visible
4. Column selection never lands on indicator columns
5. Wide columns at different positions in the table
6. Tables with varying column widths
  </action>
  <verify>`cargo test` passes all tests. All prior UAT fixes (UAT-001 through UAT-004) still work correctly.</verify>
  <done>All edge cases verified. Scroll indicators and navigation work correctly together.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All major issues fixed
- [ ] `cargo build --release` succeeds without errors
- [ ] `cargo test` passes all tests
- [ ] Right navigation past wide columns is immediate (no "inching")
- [ ] Left navigation still works correctly
- [ ] Scroll indicators appear/disappear correctly
- [ ] Column selection stays on data columns
</verification>

<success_criteria>
- UAT-005 from 10-01-ISSUES.md fixed
- Tests pass
- Ready for re-verification
</success_criteria>

<output>
After completion, create `.planning/phases/10-scroll-indicators/10-01-FIX3-SUMMARY.md`
</output>
