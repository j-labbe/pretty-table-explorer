---
phase: 04-postgresql-integration
plan: 01
type: execute
depends_on: []
files_modified: [Cargo.toml, src/db.rs, src/main.rs]
---

<objective>
Add PostgreSQL connection capability and dual-mode operation (piped input vs direct database connection).

Purpose: Enable direct database queries without requiring psql pipe, expanding utility to interactive exploration.
Output: Working `--connect` flag that establishes PostgreSQL connection and executes initial query.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-navigation/03-02-SUMMARY.md
@src/main.rs
@src/parser.rs
@Cargo.toml

**Discovery decision (Level 1 - Quick Verification):**
Use `postgres` crate (v0.19) - the synchronous wrapper around tokio-postgres. This keeps our existing sync event loop simple, no async runtime needed.

**Tech available from prior phases:**
- ratatui v0.29, crossterm v0.28 with use-dev-tty
- TableData struct for parsed data
- TableState navigation with render_stateful_widget pattern

**Key decisions:**
- 03-02: Position indicator format `[Row X/Y Col Z/N]` in title bar
- Sync postgres client avoids async complexity in TUI event loop
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add postgres dependency and create db module</name>
  <files>Cargo.toml, src/db.rs</files>
  <action>
Add postgres crate to Cargo.toml:
```toml
postgres = "0.19"
```

Create src/db.rs with:
1. `pub fn connect(connection_string: &str) -> Result<postgres::Client, postgres::Error>` - wraps Client::connect with NoTls
2. `pub fn execute_query(client: &mut postgres::Client, query: &str) -> Result<TableData, Box<dyn std::error::Error>>` - executes query, converts rows to TableData

The execute_query function should:
- Run client.query(query, &[]) to get rows
- Extract column names from row.columns() (first row if exists)
- Convert each row's values to strings using row.get::<_, Option<String>>(i).unwrap_or_default() pattern for nullable columns
- Handle empty results by returning TableData with headers only

Use `NoTls` for connections (no TLS). Avoid postgres-openssl/postgres-native-tls - keeps dependencies minimal and TLS not needed for local dev.
  </action>
  <verify>cargo check passes, src/db.rs compiles</verify>
  <done>db.rs exists with connect() and execute_query() functions, Cargo.toml has postgres dependency</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI argument parsing for --connect flag</name>
  <files>src/main.rs</files>
  <action>
Parse command-line arguments manually (no clap needed for two flags):
1. Parse args: `--connect <connection_string>` and optional `--query <sql>` (defaults to "SELECT 1")
2. Dual-mode main logic:
   - If --connect provided: call db::connect(), then db::execute_query()
   - Else: read stdin and parse_psql() (existing behavior)
3. Both paths produce TableData for the existing render loop

Add `mod db;` to imports. Handle connection errors with eprintln! and exit(1).

Connection string format: `"host=localhost user=postgres dbname=mydb"` or `"postgresql://user:pass@host/db"`

Default query when --connect without --query: `"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' LIMIT 20"` - shows available tables.
  </action>
  <verify>cargo run --help shows usage (or --connect without args shows error), cargo run with stdin still works</verify>
  <done>--connect flag parses and attempts database connection, stdin mode unchanged</done>
</task>

<task type="auto">
  <name>Task 3: Test direct DB mode with local PostgreSQL</name>
  <files>src/main.rs</files>
  <action>
Verify the dual-mode operation works:
1. Build: `cargo build`
2. Test stdin mode: `echo -e " a | b\n---+---\n 1 | 2\n(1 row)" | cargo run` - existing behavior
3. Document direct DB usage in code comment or println if connection fails

Since we can't test actual PostgreSQL connection in this environment, ensure error handling is clear:
- Connection refused → "Error: Could not connect to PostgreSQL at ..."
- Auth failed → "Error: Authentication failed for ..."
- Query error → "Error: Query failed: ..."

Add usage message when run without stdin and without --connect:
```
Usage: pretty-table-explorer [OPTIONS]
       cat data.txt | pretty-table-explorer

Options:
  --connect <CONN_STRING>  Connect to PostgreSQL database
  --query <SQL>            SQL query to execute (default: show tables)
```
  </action>
  <verify>cargo run (no args, no stdin) shows usage, cargo run --connect with invalid host shows connection error message</verify>
  <done>Clear error messages for connection failures, usage instructions shown when needed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds without errors
- [ ] `cargo test` passes (existing parser tests)
- [ ] Piped stdin mode still works: `echo "..." | cargo run`
- [ ] --connect with invalid host shows clear error
- [ ] Running without args/stdin shows usage
</verification>

<success_criteria>

- postgres dependency added
- db.rs module with connect() and execute_query()
- --connect and --query CLI flags parsed
- Dual-mode operation: stdin OR direct DB
- Clear error messages for DB failures
- No regressions in existing pipe mode
</success_criteria>

<output>
After completion, create `.planning/phases/04-postgresql-integration/04-01-SUMMARY.md`:

# Plan 04-01 Summary: PostgreSQL Connection and Query Execution

## Objective
Add direct PostgreSQL connection capability alongside existing pipe mode.

## Tasks Completed
[Document each task with specifics]

## Files Created/Modified
- Cargo.toml - Added postgres dependency
- src/db.rs - New module for database operations
- src/main.rs - CLI parsing and dual-mode logic

## Decisions Made
[Key decisions and rationale]

## Issues Encountered
[Problems and resolutions]

## Next Step
Ready for 04-02-PLAN.md (Interactive query input and search/filter)
</output>
