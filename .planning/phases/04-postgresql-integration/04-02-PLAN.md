---
phase: 04-postgresql-integration
plan: 02
type: execute
depends_on: ["04-01"]
files_modified: [src/main.rs, src/db.rs]
---

<objective>
Add interactive query input and row search/filter capabilities to the table viewer.

Purpose: Enable exploration workflow - run queries, browse results, filter to find specific data.
Output: Interactive query bar with ':' command mode and '/' search filter mode.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-postgresql-integration/04-01-SUMMARY.md
@src/main.rs
@src/db.rs

**From 04-01:**
- postgres crate available
- db::connect() and db::execute_query() functions
- --connect CLI flag for database mode
- Dual-mode operation (stdin vs direct DB)

**Tech available:**
- ratatui v0.29, crossterm v0.28
- TableData struct, TableState navigation
- Existing event loop with key handling
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AppState enum and input handling infrastructure</name>
  <files>src/main.rs</files>
  <action>
Create enum for UI modes:
```rust
enum AppMode {
    Normal,           // Regular table navigation
    QueryInput,       // ':' pressed, entering SQL query
    SearchInput,      // '/' pressed, entering search filter
}
```

Add state tracking:
- `current_mode: AppMode`
- `input_buffer: String` - text being typed
- `db_client: Option<postgres::Client>` - connection handle (Some if --connect mode)

In the event loop:
- ':' in Normal mode → switch to QueryInput, clear input_buffer
- '/' in Normal mode → switch to SearchInput, clear input_buffer
- Escape in input modes → return to Normal, clear buffer
- Enter in input modes → execute action, return to Normal

Render input bar at bottom when in input mode:
- Layout split: table area (main) + input bar (1 line at bottom)
- Input bar shows ": {input_buffer}" or "/ {input_buffer}"
- Use Paragraph widget with Block and thin border
  </action>
  <verify>cargo check passes, ':' and '/' switch modes (visible in input bar)</verify>
  <done>AppMode enum, mode switching on ':' and '/', input bar renders at bottom</done>
</task>

<task type="auto">
  <name>Task 2: Implement query execution in QueryInput mode</name>
  <files>src/main.rs</files>
  <action>
When Enter pressed in QueryInput mode:
1. If db_client is Some: execute query via db::execute_query()
2. Update table_data with results (replace existing)
3. Recalculate column widths
4. Reset table_state selection to row 0
5. Return to Normal mode

Handle query errors:
- Show error in title bar briefly: " Error: {message} "
- Keep previous data visible (don't clear on error)
- Or add status_message: Option<String> field that displays for a few render cycles

If db_client is None (pipe mode): show message "Query mode requires --connect"

Key handling in QueryInput mode:
- Printable chars → append to input_buffer
- Backspace → remove last char from input_buffer
- Enter → execute and exit mode
- Escape → cancel and exit mode
  </action>
  <verify>In --connect mode, ':SELECT 1' + Enter executes and shows result</verify>
  <done>Query input captures SQL, executes on Enter, updates table display</done>
</task>

<task type="auto">
  <name>Task 3: Implement row filter in SearchInput mode</name>
  <files>src/main.rs</files>
  <action>
Search filter operates on current result set (client-side, no new DB query):
1. Store `filter_text: String` persistently (not cleared on mode exit)
2. When rendering: filter table_data.rows to only show rows containing filter_text
3. Match is case-insensitive, searches all columns
4. Clear filter with empty search ('/'+Enter with empty buffer)

Track filtered vs unfiltered:
- `filtered_rows: Vec<Vec<String>>` computed from filter_text
- Or compute on-the-fly during render (simpler, fine for ~1000 rows)

Update position indicator to show filtered count:
- "[Row X/Y (filtered from Z)]" when filter active
- Show filter text in title: "/ {filter_text}"

Implementation:
```rust
let display_rows: Vec<&Vec<String>> = if filter_text.is_empty() {
    table_data.rows.iter().collect()
} else {
    table_data.rows.iter()
        .filter(|row| row.iter().any(|cell|
            cell.to_lowercase().contains(&filter_text.to_lowercase())
        ))
        .collect()
};
```

Reset selection to 0 when filter changes (avoids invalid index).
  </action>
  <verify>'/test' filters rows to those containing "test", empty filter shows all</verify>
  <done>Search filter works case-insensitively, position shows filtered count, 'n/N' for next/prev match optional</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds without errors
- [ ] `cargo test` passes
- [ ] ':' enters query mode, input bar visible
- [ ] '/' enters search mode, input bar visible
- [ ] Escape cancels input mode
- [ ] Query execution works in --connect mode
- [ ] Search filter reduces visible rows
- [ ] Filter cleared with empty search
- [ ] Position indicator reflects filtered count
</verification>

<success_criteria>

- AppMode enum manages Normal/QueryInput/SearchInput
- ':' command mode executes SQL queries (--connect mode only)
- '/' search mode filters displayed rows (both modes)
- Input bar renders at bottom with current input
- Query results replace table display
- Filter is case-insensitive, searches all columns
- Clear UX for mode transitions
- Phase 4 complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-postgresql-integration/04-02-SUMMARY.md`:

# Plan 04-02 Summary: Interactive Query Input and Search/Filter

## Objective
Add interactive query bar and row filtering to the table viewer.

## Tasks Completed
[Document each task with specifics]

## Files Created/Modified
- src/main.rs - AppMode enum, input handling, query execution, search filter

## Decisions Made
[Key decisions and rationale]

## Issues Encountered
[Problems and resolutions]

## Next Step
Phase 4 complete. Project milestone 1 achieved - full interactive PostgreSQL table explorer.
</output>
