---
phase: 16-memory-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/parser.rs
  - src/workspace.rs
  - src/state.rs
  - src/render.rs
  - src/export.rs
  - src/handlers.rs
  - src/main.rs
  - src/streaming.rs
autonomous: true

must_haves:
  truths:
    - "Application compiles and runs with interned string storage"
    - "All existing features work identically (search, export, column ops, navigation)"
    - "Streaming data load still works with interned storage"
  artifacts:
    - path: "Cargo.toml"
      provides: "lasso dependency"
      contains: "lasso"
    - path: "src/parser.rs"
      provides: "TableData with Vec<Vec<Spur>> rows and Rodeo interner"
      contains: "Spur"
    - path: "src/workspace.rs"
      provides: "Tab with Rodeo interner field"
      contains: "interner"
    - path: "src/render.rs"
      provides: "Symbol resolution for display rendering"
      contains: "resolve"
    - path: "src/export.rs"
      provides: "Symbol resolution before CSV/JSON serialization"
      contains: "resolve"
    - path: "src/handlers.rs"
      provides: "Symbol resolution for search/filter operations"
      contains: "resolve"
  key_links:
    - from: "src/parser.rs"
      to: "src/workspace.rs"
      via: "TableData with Spur rows consumed by Tab"
      pattern: "TableData.*rows.*Spur"
    - from: "src/workspace.rs"
      to: "src/render.rs"
      via: "Tab.interner used to resolve symbols for display"
      pattern: "interner\\.resolve"
    - from: "src/workspace.rs"
      to: "src/export.rs"
      via: "Interner resolves symbols before export serialization"
      pattern: "resolve.*export|export.*resolve"
    - from: "src/streaming.rs"
      to: "src/main.rs"
      via: "String rows from channel interned during append"
      pattern: "get_or_intern"
---

<objective>
Migrate table data storage from Vec<Vec<String>> to Vec<Vec<Spur>> using lasso string interning, reducing memory usage by 50-80% for datasets with repetitive column values.

Purpose: This is the core architectural change for MEM-01. By storing each unique string once and using 32-bit Spur symbols as references, we eliminate massive string duplication in large datasets (1.8M rows). Headers remain as Vec<String> (negligible memory, simplifies code).

Output: Application compiles and runs with interned storage. All features (search, filter, export, column controls, navigation, streaming) work identically to pre-migration behavior.
</objective>

<execution_context>
@/home/jlabbe/.claude/get-shit-done/workflows/execute-plan.md
@/home/jlabbe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-memory-optimization/16-RESEARCH.md
@.planning/phases/15-streaming-load/15-01-SUMMARY.md
@.planning/phases/15-streaming-load/15-02-SUMMARY.md
@src/parser.rs
@src/workspace.rs
@src/render.rs
@src/export.rs
@src/handlers.rs
@src/state.rs
@src/main.rs
@src/streaming.rs
@src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lasso dependency and migrate core data types</name>
  <files>
    Cargo.toml
    src/parser.rs
    src/workspace.rs
    src/state.rs
  </files>
  <action>
1. Add `lasso = "0.7"` to [dependencies] in Cargo.toml. Do NOT add rustc-hash (keep it simple).

2. In `src/parser.rs`:
   - Add `use lasso::{Rodeo, Spur};`
   - Change `TableData` struct:
     ```rust
     pub struct TableData {
         pub headers: Vec<String>,        // Keep as String (small, never duplicated)
         pub rows: Vec<Vec<Spur>>,        // CHANGED: Store interned symbols
         pub interner: Rodeo,             // NEW: String interner for this table's data
     }
     ```
   - Add `impl TableData` methods:
     - `pub fn resolve(&self, spur: &Spur) -> &str { self.interner.resolve(spur) }` for convenient resolution
     - `pub fn resolve_row(&self, row: &[Spur]) -> Vec<String>` that resolves all symbols in a row to owned Strings (needed for export)
   - Implement `Clone` manually for TableData since Rodeo does not implement Clone:
     ```rust
     impl Clone for TableData {
         fn clone(&self) -> Self {
             let mut new_interner = Rodeo::default();
             let new_rows: Vec<Vec<Spur>> = self.rows.iter().map(|row| {
                 row.iter().map(|spur| {
                     let s = self.interner.resolve(spur);
                     new_interner.get_or_intern(s)
                 }).collect()
             }).collect();
             TableData {
                 headers: self.headers.clone(),
                 rows: new_rows,
                 interner: new_interner,
             }
         }
     }
     ```
     Remove the `#[derive(Clone)]` from TableData.
   - Also implement `Debug` manually (since Rodeo may not derive Debug):
     ```rust
     impl std::fmt::Debug for TableData {
         fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
             f.debug_struct("TableData")
                 .field("headers", &self.headers)
                 .field("rows_count", &self.rows.len())
                 .finish()
         }
     }
     ```
     Remove `#[derive(Debug)]` from TableData.
   - Update `parse_psql()` function to intern strings:
     ```rust
     let mut interner = Rodeo::default();
     // In the row parsing loop, replace:
     //   let row: Vec<String> = line.split('|')...
     // with:
     //   let row: Vec<Spur> = line.split('|')
     //       .map(|s| interner.get_or_intern(s.trim()))
     //       .collect();
     ```
     Return `TableData { headers, rows, interner }`.
   - `parse_psql_header()` stays unchanged (returns Vec<String>, no interning).
   - `parse_psql_line()` stays returning `Option<Vec<String>>` because it is called from the streaming background thread which does NOT have access to the interner (Rodeo is not Send). The interning happens in the main thread when appending rows.
   - Update all unit tests in parser.rs to account for the new type. Tests that check `table.rows[0]` need to resolve symbols first:
     ```rust
     let resolved: Vec<String> = table.rows[0].iter()
         .map(|s| table.resolve(s).to_string())
         .collect();
     assert_eq!(resolved, vec!["1", "Alice", "30"]);
     ```

3. In `src/workspace.rs`:
   - Remove the `Rodeo` from Tab (the interner now lives inside `TableData`).
   - Update `Tab::update_cached_widths()`: Instead of `cell.len()`, use `self.data.resolve(cell).len()` (where cell is a `&Spur`):
     ```rust
     for row in &self.data.rows[start..end] {
         for (i, cell) in row.iter().enumerate() {
             if i < num_cols {
                 let w = (self.data.resolve(cell).len() + 1) as u16;
                 if w > self.cached_auto_widths[i] {
                     self.cached_auto_widths[i] = w;
                 }
             }
         }
     }
     ```
   - Add helper method `Tab::intern_and_append_rows(&mut self, string_rows: Vec<Vec<String>>)`:
     ```rust
     pub fn intern_and_append_rows(&mut self, string_rows: Vec<Vec<String>>) {
         for row in string_rows {
             let interned_row: Vec<Spur> = row.iter()
                 .map(|cell| self.data.interner.get_or_intern(cell.as_str()))
                 .collect();
             self.data.rows.push(interned_row);
         }
     }
     ```
   - Update `sample_data()` test helper and all workspace unit tests to create TableData with interner:
     ```rust
     fn sample_data() -> TableData {
         let mut interner = Rodeo::default();
         let rows = vec![
             vec![interner.get_or_intern("1"), interner.get_or_intern("Alice")],
             vec![interner.get_or_intern("2"), interner.get_or_intern("Bob")],
         ];
         TableData {
             headers: vec!["id".to_string(), "name".to_string()],
             rows,
             interner,
         }
     }
     ```

4. In `src/state.rs`:
   - Update `PaneRenderData.display_rows` from `Vec<Vec<String>>` to `Vec<Vec<String>>` -- KEEP as Vec<Vec<String>>. The render data is a resolved snapshot for the draw closure. Resolution happens in `build_pane_render_data()` when extracting the viewport window. This avoids passing the interner into the draw closure.
   - No changes needed to PaneRenderData itself since it already stores resolved strings.
  </action>
  <verify>
    `cargo check` passes with no errors. The code will not fully compile yet because render.rs, export.rs, handlers.rs, and main.rs still reference the old Vec<Vec<String>> row type, but the core types are migrated.

    Actually, since we need a compiling state, ensure parser.rs unit tests pass: `cargo test --lib parser::tests`
  </verify>
  <done>
    TableData stores `Vec<Vec<Spur>>` rows with a `Rodeo` interner. Parser functions produce interned data. Tab has `intern_and_append_rows()` for streaming integration. Parser unit tests pass with symbol resolution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all consumers to work with interned storage</name>
  <files>
    src/render.rs
    src/export.rs
    src/handlers.rs
    src/main.rs
    src/streaming.rs
  </files>
  <action>
1. In `src/render.rs`:
   - Update `calculate_auto_widths()`: Iterate over `data.rows` and resolve each Spur to get string length:
     ```rust
     for row in &data.rows {
         for (i, cell) in row.iter().enumerate() {
             if i < num_cols {
                 widths[i] = widths[i].max(data.resolve(cell).len());
             }
         }
     }
     ```
   - Update `build_pane_render_data()`: When building `display_rows`, resolve symbols to strings for the PaneRenderData snapshot:
     - For unfiltered path:
       ```rust
       let rows: Vec<Vec<String>> = tab.data.rows[start..end].iter()
           .map(|row| row.iter().map(|s| tab.data.resolve(s).to_string()).collect())
           .collect();
       ```
     - For filtered path: The filter comparison needs to resolve symbols:
       ```rust
       .filter(|(_, row)| {
           row.iter().any(|cell| {
               tab.data.resolve(cell).to_lowercase().contains(&filter_lower)
           })
       })
       ```
       And when collecting filtered rows:
       ```rust
       let rows: Vec<Vec<String>> = filtered_indices[start..end].iter()
           .map(|&i| tab.data.rows[i].iter().map(|s| tab.data.resolve(s).to_string()).collect())
           .collect();
       ```
   - `render_table_pane()` already operates on `PaneRenderData` which has resolved `Vec<Vec<String>>`, so NO changes needed there.

2. In `src/export.rs`:
   - Update `export_csv()` and `export_json()` to resolve symbols. Since export receives `&TableData`, resolve before serialization:
     - CSV: Change the row iteration:
       ```rust
       for row in &data.rows {
           let values: Vec<String> = visible_cols.iter()
               .map(|&i| row.get(i).map(|s| data.resolve(s).to_string()).unwrap_or_default())
               .collect();
           let str_values: Vec<&str> = values.iter().map(|s| s.as_str()).collect();
           wtr.write_record(&str_values)...
       ```
     - JSON: Similarly resolve:
       ```rust
       for row in &data.rows {
           let mut row_obj: HashMap<&str, String> = HashMap::new();
           for &col_idx in visible_cols {
               if let Some(header) = data.headers.get(col_idx) {
                   let value = row.get(col_idx)
                       .map(|s| data.resolve(s).to_string())
                       .unwrap_or_default();
                   row_obj.insert(header.as_str(), value);
               }
           }
           rows_json.push(row_obj);
       }
       ```
     - Update the export unit tests in export.rs to create TableData with interner (same pattern as parser tests).

3. In `src/handlers.rs`:
   - Update `handle_normal_mode()` Enter handler (TableList mode): The display_rows filter and table name extraction need symbol resolution:
     ```rust
     let display_rows: Vec<&Vec<Spur>> = if tab.filter_text.is_empty() {
         tab.data.rows.iter().collect()
     } else {
         tab.data.rows.iter()
             .filter(|row| {
                 row.iter().any(|cell| {
                     tab.data.resolve(cell).to_lowercase().contains(&filter_lower)
                 })
             })
             .collect()
     };
     // When getting table name:
     if let Some(tbl_spur) = row.first() {
         let tbl_name = tab.data.resolve(tbl_spur).to_string();
         // ... use tbl_name
     }
     ```
   - Update `calculate_auto_widths` call in column width adjustment (+/- handlers) -- this function already updated in render.rs, just ensure it receives the right type.
   - `handle_export_filename()` passes `&tab.data` to export -- export.rs handles resolution internally, so no change needed here.

4. In `src/main.rs`:
   - Update streaming row append section: Instead of directly extending `tab.data.rows`, use the new `intern_and_append_rows()`:
     ```rust
     // Replace:
     //   tab.data.rows.extend(new_rows);
     // With:
     tab.intern_and_append_rows(new_rows);
     ```
     Do this in BOTH places where rows are appended (the main poll section and the "still draining" section).
   - Remove the `rows.reserve()` call before extend since `intern_and_append_rows` handles pushing internally. OR keep the reserve by accessing `tab.data.rows` capacity directly.
   - Update `table_list_cache` creation: `table_data.clone()` now uses the manual Clone impl, which is correct.
   - The initial `TableData` creation for stdin mode needs to include an interner:
     ```rust
     let initial_data = parser::TableData {
         headers: loader.headers().to_vec(),
         rows: Vec::with_capacity(100_000),
         interner: lasso::Rodeo::default(),
     };
     ```
   - Add `use lasso::Rodeo;` (or use qualified path).
   - In the Esc handler (back to table list): `tab.data = cached.clone()` already works because we implemented Clone for TableData.

5. In `src/streaming.rs`:
   - No changes needed. StreamingParser still sends `Vec<Vec<String>>` through the channel because Rodeo is not Send/Sync. Interning happens on the main thread when appending to the Tab. This is correct by design.

6. Run `cargo build` to ensure compilation. Fix any remaining type mismatches.
7. Run `cargo test` to ensure all unit tests pass (parser, workspace, export, column, search tests).
8. Run `cargo test --test search_tests --test export_tests --test column_tests` to verify all 33 integration tests pass.
  </action>
  <verify>
    1. `cargo build` succeeds with no errors
    2. `cargo clippy` has no warnings (or only pre-existing ones)
    3. `cargo test` passes ALL tests (unit + integration)
    4. `cargo test --test search_tests` passes all 10 search tests
    5. `cargo test --test export_tests` passes all 9 export tests
    6. `cargo test --test column_tests` passes all 14 column tests
  </verify>
  <done>
    All code paths (render, export, search, filter, column operations, streaming, navigation) work correctly with interned string storage. All 33+ integration tests pass. Application compiles cleanly. Zero regressions from the storage migration.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- clean compilation with lasso dependency
2. `cargo test` -- all unit and integration tests pass
3. `cargo clippy` -- no new warnings
4. Manual smoke test: `seq 1 100 | awk 'BEGIN{print " id | name\n----+------"}{print " " $1 " | row" $1}' | cargo run` -- verify data displays correctly
</verification>

<success_criteria>
- TableData uses `Vec<Vec<Spur>>` with `Rodeo` interner (verified by grep for `Spur` in parser.rs)
- All 33 integration tests pass (search: 10, export: 9, column: 14)
- All unit tests pass
- Application compiles and runs with piped data
- Search/filter resolves symbols correctly (case-insensitive matching works)
- Export resolves symbols (CSV/JSON contain actual string values, not symbol IDs)
- Streaming append interns strings on main thread (verify `get_or_intern` in main.rs or workspace.rs)
</success_criteria>

<output>
After completion, create `.planning/phases/16-memory-optimization/16-01-SUMMARY.md`
</output>
