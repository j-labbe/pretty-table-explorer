---
phase: 16-memory-optimization
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/render.rs
autonomous: true

must_haves:
  truths:
    - "User sees current memory usage (RSS in MB) displayed in the status bar"
    - "Memory display updates periodically without impacting frame rate"
    - "Memory usage for large datasets is measurably reduced compared to pre-interning baseline"
  artifacts:
    - path: "Cargo.toml"
      provides: "sysinfo dependency"
      contains: "sysinfo"
    - path: "src/main.rs"
      provides: "Memory tracking with throttled sysinfo refresh"
      contains: "sysinfo"
    - path: "src/main.rs"
      provides: "Memory display in status bar"
      contains: "memory_mb"
  key_links:
    - from: "src/main.rs"
      to: "sysinfo::System"
      via: "Periodic process memory refresh in event loop"
      pattern: "refresh_process|sys\\.process"
    - from: "src/main.rs"
      to: "status bar rendering"
      via: "Memory MB displayed alongside existing status info"
      pattern: "Memory.*MB|memory_mb"
---

<objective>
Add runtime memory tracking to the status bar using sysinfo crate, displaying current RSS in MB. This completes MEM-02 and provides visible confirmation of MEM-01 memory savings.

Purpose: Users need to see that memory optimization is working. Displaying RSS in the status bar gives real-time feedback during large data loads and validates the interning savings from Plan 01.

Output: Memory usage displayed in status bar (e.g., "Mem: 342 MB"), refreshed every ~30 frames. sysinfo dependency added to Cargo.toml.
</objective>

<execution_context>
@/home/jlabbe/.claude/get-shit-done/workflows/execute-plan.md
@/home/jlabbe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-memory-optimization/16-RESEARCH.md
@.planning/phases/16-memory-optimization/16-01-SUMMARY.md
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sysinfo dependency and integrate memory tracking into event loop</name>
  <files>
    Cargo.toml
    src/main.rs
  </files>
  <action>
1. Add `sysinfo = "0.33"` to [dependencies] in Cargo.toml.

2. In `src/main.rs`, add imports:
   ```rust
   use sysinfo::{System, RefreshKind, ProcessRefreshKind, Pid};
   ```

3. Before the main event loop, initialize sysinfo:
   ```rust
   // Memory tracking
   let mut sys = System::new_with_specifics(
       RefreshKind::new().with_processes(ProcessRefreshKind::new().with_memory())
   );
   let pid: Pid = sysinfo::get_current_pid().expect("Failed to get current PID");
   let mut memory_mb: u64 = 0;
   let mut frame_count: u64 = 0;
   ```

4. At the TOP of the main event loop (before rendering), add throttled memory refresh:
   ```rust
   // Refresh memory stats every ~30 frames (~1 second at ~30 FPS)
   frame_count += 1;
   if frame_count % 30 == 0 {
       sys.refresh_process(pid);
       if let Some(process) = sys.process(pid) {
           memory_mb = process.memory() / 1024 / 1024;
       }
   }
   ```

5. Add memory display to the status bar. In the single-pane rendering section where `status_info` is built, prepend memory info:
   ```rust
   let mem_info = format!("Mem: {} MB ", memory_mb);
   ```
   Include `mem_info` in the title/status string. There are two rendering paths:

   **Single pane mode:** In the title construction where `status_info` is used, add memory:
   ```rust
   let title = format!(
       "{}{} {} {}{}{}{}",
       tab_bar, context_label, position, filter_info, mem_info, status_info, controls
   );
   ```

   **Split view mode:** In the controls area at the bottom, add memory:
   ```rust
   let controls_widget = Paragraph::new(format!("{}{}{}", mem_info, status_info, controls))
       .style(Style::default().fg(Color::DarkGray));
   ```

   The `mem_info` variable should be constructed BEFORE the `terminal.draw()` closure (alongside other captured state):
   ```rust
   let mem_info = if memory_mb > 0 {
       format!("Mem: {} MB ", memory_mb)
   } else {
       String::new()  // Don't show 0 MB before first refresh
   };
   ```

6. Ensure the first memory reading happens immediately (not after 30 frames). Do the initial refresh right after creating `sys`:
   ```rust
   sys.refresh_process(pid);
   if let Some(process) = sys.process(pid) {
       memory_mb = process.memory() / 1024 / 1024;
   }
   ```
  </action>
  <verify>
    1. `cargo build` succeeds
    2. `cargo test` -- all tests still pass (memory tracking is main-only, no impact on lib tests)
    3. Manual test: `seq 1 1000 | awk 'BEGIN{print " id | val\n----+------"}{print " " $1 " | data" $1}' | cargo run` -- verify "Mem: X MB" appears in status bar
    4. Verify memory display updates (watch for value changes when loading larger data)
  </verify>
  <done>
    Memory usage (RSS in MB) displayed in status bar for both single-pane and split-view modes. Refreshes every ~30 frames without impacting frame rate. Shows accurate process memory including all allocations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Final validation and integration test confirmation</name>
  <files>
    tests/search_tests.rs
    tests/export_tests.rs
    tests/column_tests.rs
  </files>
  <action>
1. Run the full integration test suite to confirm Plan 01's migration + Plan 02's changes don't break anything:
   ```bash
   cargo test --test search_tests --test export_tests --test column_tests
   ```

2. If any integration tests fail due to the TableData type change (tests create TableData directly), update them to include an interner:
   - Each test that constructs `TableData { headers: ..., rows: ... }` needs to be updated to:
     ```rust
     use lasso::Rodeo;

     let mut interner = Rodeo::default();
     let rows = vec![
         vec![
             interner.get_or_intern("1"),
             interner.get_or_intern("Alice"),
             interner.get_or_intern("30"),
         ],
         // ... more rows
     ];
     let data = TableData {
         headers: vec!["id".to_string(), "name".to_string(), "age".to_string()],
         rows,
         interner,
     };
     ```
   - Tests that read cell values need to resolve symbols:
     ```rust
     // Instead of: assert!(result.contains("Alice"))
     // The export functions should already produce resolved strings
     // So CSV/JSON output assertions should work unchanged
     ```

3. Run `cargo clippy` and fix any warnings.

4. Run `cargo test` (full suite) -- all tests must pass.

5. If the search integration tests construct filter scenarios by checking row contents, verify they still work. The search filtering in render.rs resolves symbols before comparison, so the behavior should be identical.

6. Run a final build check: `cargo build --release` to ensure release profile compiles.

NOTE: If Plan 01 already updated all integration tests (it should, as part of making `cargo test` pass), this task primarily serves as explicit verification and any remaining fixups. The tests in tests/ directory import `pretty_table_explorer::parser::TableData` and construct it directly, so they MUST be updated to include the interner field.
  </action>
  <verify>
    1. `cargo test` passes ALL tests (expect 64+ tests: 31+ unit + 33 integration)
    2. `cargo test --test search_tests` -- 10 tests pass
    3. `cargo test --test export_tests` -- 9 tests pass
    4. `cargo test --test column_tests` -- 14 tests pass
    5. `cargo clippy` -- no warnings
    6. `cargo build --release` -- clean compilation
  </verify>
  <done>
    All 33 integration tests pass with interned storage. No regressions in search, export, or column operations. Release build compiles cleanly. Phase 16 requirements MEM-01 (reduced memory via interning) and MEM-02 (memory display in status bar) are both satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` -- clean compilation
2. `cargo test` -- all unit and integration tests pass
3. `cargo clippy` -- no new warnings
4. Manual test with piped data: verify memory display shows in status bar
5. Compare memory usage: load moderate dataset before/after interning (if possible)
</verification>

<success_criteria>
- "Mem: X MB" visible in status bar during normal operation (MEM-02)
- Memory refreshes periodically without frame rate impact (~every 30 frames)
- All 33 integration tests pass (regression protection for MEM-01)
- Release build compiles cleanly
- sysinfo dependency present in Cargo.toml
</success_criteria>

<output>
After completion, create `.planning/phases/16-memory-optimization/16-02-SUMMARY.md`
</output>
