---
phase: 06-installation-updates
plan: 02
type: execute
depends_on: []
files_modified: [Cargo.toml, src/main.rs]
---

<objective>
Add self-update command to pte so users can update to latest version with `pte update`.

Purpose: Users can keep their installation current without re-running the install script.
Output: `pte update` subcommand that checks for and installs newer versions.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-release-infrastructure/05-02-SUMMARY.md
@src/main.rs
@Cargo.toml

**From Phase 5:**
- Version in Cargo.toml: 1.0.0
- Binary has --version flag via clap
- Releases at: https://github.com/{owner}/{repo}/releases/latest

**GitHub API:**
- Latest release: https://api.github.com/repos/{owner}/{repo}/releases/latest
- Returns JSON with tag_name, assets array
- Asset download URLs in assets[].browser_download_url

**Self-replacement strategy:**
- Download new binary to temp file
- Verify checksum
- Replace current executable (std::env::current_exe())
- On Unix: can replace running binary
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HTTP client dependency</name>
  <files>Cargo.toml</files>
  <action>Add ureq dependency for HTTP requests (synchronous, minimal, no async runtime needed):

```toml
ureq = { version = "2", features = ["json"] }
```

ureq is preferred over reqwest because:
- Synchronous API (no async runtime needed)
- Much smaller binary size
- Perfect for simple GitHub API calls

Also add sha2 for checksum verification:
```toml
sha2 = "0.10"
```</action>
  <verify>cargo check passes</verify>
  <done>ureq and sha2 dependencies added, project compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement update subcommand</name>
  <files>src/main.rs</files>
  <action>Modify the Cli struct to add an Update subcommand:

1. Add clap subcommand:
```rust
#[derive(Parser, Debug)]
#[command(name = "pte", version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,

    /// Connect to PostgreSQL database
    #[arg(long)]
    connect: Option<String>,

    /// SQL query to execute
    #[arg(long)]
    query: Option<String>,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Update to the latest version
    Update,
}
```

2. Create update module or function with logic:
   - Detect current platform (same logic as install script: uname equivalent)
   - Fetch https://api.github.com/repos/{REPO}/releases/latest
   - Parse JSON for tag_name (latest version)
   - Compare with current version (env!("CARGO_PKG_VERSION"))
   - If newer: download binary, verify checksum, replace self
   - Use std::env::current_exe() to find current binary path

3. Platform detection:
   - Use std::env::consts::OS and std::env::consts::ARCH
   - Map: linux/x86_64 → pte-linux-x86_64
   - Map: linux/aarch64 → pte-linux-aarch64
   - Map: macos/x86_64 → pte-macos-x86_64
   - Map: macos/aarch64 → pte-macos-aarch64

4. Self-replacement:
   - Download to temp file
   - Download checksums.txt, extract expected hash
   - Compute sha256 of downloaded file
   - If match: std::fs::rename(temp, current_exe)
   - chmod +x on Unix

5. Error handling:
   - Network errors → helpful message
   - Version check → "Already up to date" if current >= latest
   - Unsupported platform → clear error

IMPORTANT: Keep the REPO constant configurable (const GITHUB_REPO: &str = "yourusername/pretty-table-explorer") so users who fork can change it.

In main(), check for subcommand before the existing stdin/connect logic:
```rust
fn main() {
    let cli = Cli::parse();

    if let Some(Commands::Update) = cli.command {
        if let Err(e) = do_update() {
            eprintln!("Update failed: {}", e);
            std::process::exit(1);
        }
        return;
    }

    // ... existing logic
}
```</action>
  <verify>cargo build --release succeeds, ./target/release/pte update runs (will fail on network but should show attempt)</verify>
  <done>pte update command exists, attempts to check GitHub for updates, handles platform detection for all 4 targets</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds
- [ ] `pte --help` shows update subcommand
- [ ] `pte update` runs and attempts GitHub API call
- [ ] Platform detection covers linux/macos x86_64/aarch64
- [ ] Existing functionality (piped input, --connect) still works
</verification>

<success_criteria>

- Update subcommand added to CLI
- GitHub API integration for checking latest version
- Platform detection for binary selection
- Self-replacement logic with checksum verification
- No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/06-installation-updates/06-02-SUMMARY.md`
</output>
