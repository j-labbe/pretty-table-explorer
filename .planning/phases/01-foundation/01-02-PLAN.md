---
phase: 01-foundation
plan: 02
type: execute
depends_on: ["01-01"]
files_modified: [src/main.rs]
---

<objective>
Create basic terminal UI with ratatui event loop and quit handling.

Purpose: Establish the TUI scaffold that all interactive features will build on.
Output: Running terminal application that displays a placeholder and quits on 'q' or Ctrl+C.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@Cargo.toml
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up terminal with ratatui</name>
  <files>src/main.rs</files>
  <action>Replace default main.rs with ratatui terminal setup:
1. Import ratatui prelude and crossterm
2. Create function to initialize terminal (enable raw mode, enter alternate screen, create Terminal with CrosstermBackend)
3. Create function to restore terminal (disable raw mode, leave alternate screen)
4. Use panic hook to restore terminal on crash
5. Main function should init terminal, defer restore, and return Result<()>

Follow ratatui's recommended setup pattern. Use crossterm as the backend (not termion). Handle errors with Result, not unwrap.</action>
  <verify>cargo build succeeds, running ./target/debug/pretty-table-explorer enters alternate screen then exits</verify>
  <done>Terminal initializes in raw mode, alternate screen active, terminal restored on exit</done>
</task>

<task type="auto">
  <name>Task 2: Add event loop with quit handling</name>
  <files>src/main.rs</files>
  <action>Add main event loop:
1. Use crossterm's event::poll with 250ms timeout for responsive feel
2. Handle KeyEvent for 'q' key and Ctrl+C to exit gracefully
3. Loop until quit signal received
4. Clear terminal on exit

Event loop structure:
```
loop {
    terminal.draw(...)?;
    if poll(Duration::from_millis(250))? {
        if let Event::Key(key) = read()? {
            if key.code == KeyCode::Char('q') ||
               (key.modifiers.contains(KeyModifiers::CONTROL) && key.code == KeyCode::Char('c')) {
                break;
            }
        }
    }
}
```

Do NOT use blocking read() without poll - it will make the app unresponsive.</action>
  <verify>Run app, press 'q' - should exit cleanly. Run app, press Ctrl+C - should exit cleanly.</verify>
  <done>Event loop runs, 'q' quits, Ctrl+C quits, no zombie processes</done>
</task>

<task type="auto">
  <name>Task 3: Render placeholder content</name>
  <files>src/main.rs</files>
  <action>In the terminal.draw() call, render a simple placeholder:
1. Create a Block with title "Pretty Table Explorer" and borders
2. Render a Paragraph inside with text "Press 'q' to quit"
3. Center the content in the terminal

This proves the rendering pipeline works and gives visual feedback that the app is running. Use ratatui's Block, Paragraph, and Layout widgets.

Keep it simple - Phase 2 will replace this with actual table rendering.</action>
  <verify>Run app, see bordered box with title and quit instructions displayed</verify>
  <done>Placeholder UI visible, title displayed, quit instruction shown, borders render correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] App runs without crashing
- [ ] 'q' key exits cleanly
- [ ] Ctrl+C exits cleanly
- [ ] Terminal restored after exit (no garbled text)
- [ ] Placeholder UI displays with title and borders
</verification>

<success_criteria>

- Terminal UI initializes and restores properly
- Event loop handles quit keys
- Placeholder renders correctly
- Phase 1 Foundation complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
