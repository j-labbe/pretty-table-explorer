---
phase: 02-table-rendering
plan: 01
type: execute
depends_on: []
files_modified: [src/parser.rs, src/main.rs]
---

<objective>
Parse piped psql output into structured table data that can be rendered.

Purpose: Transform raw psql text format into Row/Column data structures for table rendering.
Output: Parser module that extracts headers and data rows from stdin.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/main.rs

**Prior decisions:**
- Rust 2021 edition with ratatui v0.29, crossterm v0.28
- 250ms poll timeout for event handling
- Panic hook for crash recovery

**psql output format:**
```
 column1  | column2  | column3
----------+----------+---------
 value1   | value2   | value3
 value4   | value5   | value6
(2 rows)
```

Key characteristics:
- Header row has column names separated by ` | `
- Separator row with dashes and `+` characters
- Data rows with ` | ` separators
- Footer line with row count (ignore)
- Values are trimmed, spacing varies
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parser module with TableData struct</name>
  <files>src/parser.rs</files>
  <action>Create parser.rs with:

  1. `TableData` struct holding:
     - `headers: Vec<String>` - column names
     - `rows: Vec<Vec<String>>` - data rows

  2. `parse_psql(input: &str) -> Option<TableData>` function:
     - Split input by newlines
     - First non-empty line is header row
     - Skip separator line (contains `---`)
     - Parse remaining lines as data rows until `(N rows)` footer
     - Split each line by ` | ` and trim whitespace
     - Return None if input is empty or malformed

  Use simple string operations (split, trim). Don't use regex - overkill for this format.</action>
  <verify>Create a test in the same file using `#[cfg(test)]` module that parses sample psql output and verifies headers and row counts</verify>
  <done>parser.rs exists with TableData struct and parse_psql function. Unit test passes with sample data.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate parser with stdin reading</name>
  <files>src/main.rs</files>
  <action>Modify main.rs to:

  1. Add `mod parser;` declaration at top
  2. Add `use std::io::Read;` for stdin reading
  3. Before TUI init, read all of stdin into a String:
     ```rust
     let mut input = String::new();
     io::stdin().read_to_string(&mut input)?;
     ```
  4. Parse with `parser::parse_psql(&input)`
  5. If parsing fails, print error and exit (don't enter TUI)
  6. Store parsed TableData for use in rendering (Phase 2 Plan 2)

  For now, just print the number of columns and rows to verify parsing works, then continue to TUI. The actual table rendering comes in 02-02.</action>
  <verify>Echo sample psql output: `echo -e " id | name\n----+-----\n 1  | foo\n 2  | bar\n(2 rows)" | cargo run` should print column/row counts</verify>
  <done>main.rs reads stdin, parses with parser module, handles empty/invalid input gracefully</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds without errors
- [ ] `cargo test` passes parser unit tests
- [ ] Piped input is parsed correctly: `echo -e " a | b\n---+---\n 1 | 2\n(1 rows)" | cargo run`
- [ ] Empty stdin handled gracefully (error message, no crash)
</verification>

<success_criteria>

- parser.rs module exists with TableData and parse_psql
- Unit tests verify parsing correctness
- main.rs reads stdin and parses before TUI
- Invalid input produces clear error, doesn't crash
</success_criteria>

<output>
After completion, create `.planning/phases/02-table-rendering/02-01-SUMMARY.md`
</output>
